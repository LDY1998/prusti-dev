use proc_macro2::{TokenStream};
use quote::quote_spanned;
use syn::spanned::Spanned;

/**
This file implemented a series of functions to generate a macro for exporting source code
The fn generate_macro_for_export is the entry point, where it generates the whole macro
The inner tokens of macros is composed by expanding all mod declarations at this level and
the export item itself
The macro name is generated by export item's identifier with hash of its module_path
Some concrete examples can be found on https://hackmd.io/xT60CoK6TG6a4DCQgUMC4w#Guide-level-explanation
*/

/// generate a hash of path
fn hash_path(path: syn::Path) -> u64 {
    use std::{
        collections::hash_map::DefaultHasher,
        hash::{Hash, Hasher},
    };
    let mut hasher = DefaultHasher::new();
    path.hash(&mut hasher);
    hasher.finish()
}

/// generate a macro identifier with given path in this format:
/// prustiexport_{last_segment in path}_{hash(path)}
/// First segment is for identifying a macro that is generated by prusti export
pub fn generate_macro_ident(path: syn::Path) -> syn::Ident {
    let ident = path.segments.last().unwrap().ident.to_owned();
    let span = path.span();
    println!("path for macro ident: {:?}", &path);
    syn::Ident::new(
        &format!("{}_{}_{}", "prustiexport", ident, hash_path(path)),
        span,
    )
}

pub fn rewrite_export_spec(path: &syn::Path, item: &syn::Item) -> syn::Result<TokenStream> {
    let mut ts_acc = TokenStream::new();
    match item {
        syn::Item::Fn(item_fn) => ts_acc.extend(rewrite_fn(item_fn, path.clone()).unwrap()),
        syn::Item::Mod(item_mod) => ts_acc.extend(rewrite_mod(item_mod, path.clone()).unwrap()),
        syn::Item::Impl(item_impl) => ts_acc.extend(rewrite_impl(item_impl, path.clone()).unwrap()),
        _ => {
            return Err(syn::Error::new(item.span(), "Unsupported export!"));
        }
    }
    Ok(ts_acc)
}

fn rewrite_mod(item_mod: &syn::ItemMod, mut path: syn::Path) -> syn::Result<TokenStream> {
    let mut ts_acc = TokenStream::new();
    path.segments.push(syn::PathSegment {
        ident: item_mod.ident.clone(),
        arguments: syn::PathArguments::None,
    });
    for item in item_mod.content.as_ref().unwrap().1.iter() {
        match item {
            syn::Item::Fn(item_fn) => ts_acc.extend(rewrite_fn(item_fn, path.clone()).unwrap()),
            syn::Item::Mod(item_mod) => ts_acc.extend(rewrite_mod(item_mod, path.clone()).unwrap()),
            syn::Item::Impl(item_impl) => {
                ts_acc.extend(rewrite_impl(item_impl, path.clone()).unwrap())
            }
            _ => {
                // return Err(syn::Error::new(item_mod.span(), "Unsupported export!"));
                continue;
            }
        }
    }

    ts_acc.extend(item_mod.export(path));
    Ok(ts_acc)
}

fn rewrite_fn(item_fn: &syn::ItemFn, mut path: syn::Path) -> syn::Result<TokenStream> {
    path.segments.push(syn::PathSegment {
        ident: item_fn.sig.ident.clone(),
        arguments: syn::PathArguments::None,
    });
    Ok(item_fn.export(path))
}

fn rewrite_impl(item_impl: &syn::ItemImpl, mut path: syn::Path) -> syn::Result<TokenStream> {
    let mut ts_acc = TokenStream::new();
    if let syn::Type::Path(type_path) = item_impl.self_ty.as_ref() {
        path.segments.extend(type_path.path.clone().segments);
    }
    for item in item_impl.items.iter() {
        let mut method_path = path.clone();
        match item {
            syn::ImplItem::Method(item_method) => {
                method_path.segments.push(syn::PathSegment {
                    ident: item_method.sig.ident.clone(),
                    arguments: syn::PathArguments::None,
                });
                ts_acc.extend(rewrite_method(item_method, method_path).unwrap())
            }
            _ => {
                continue;
            }
        }
    }

    ts_acc.extend(item_impl.export(path));
    Ok(ts_acc)
}

fn rewrite_method(item_method: &syn::ImplItemMethod, path: syn::Path) -> syn::Result<TokenStream> {
    let macro_ident = generate_macro_ident(path);
    Ok(quote_spanned! {item_method.span()=>
        macro_rules! #macro_ident {
            () => {
                #item_method
            };
        }
    })
}

pub fn parse_valid_export_path(attr: TokenStream) -> syn::Result<syn::Path> {
    let span = attr.span();
    if attr.is_empty() {
        Err(syn::Error::new(span, "export path must be non-empty"))
    } else if attr.to_string().trim() == "::" {
        Ok(syn::Path {
            leading_colon: None,
            segments: syn::punctuated::Punctuated::new(),
        })
    } else {
        syn::parse2(attr).map_err(|_e| syn::Error::new(span, "invalid export path"))
    }
}

trait PrustiExport {
    fn export(&self, path: syn::Path) -> TokenStream;
}

impl PrustiExport for syn::ItemMod {
    fn export(&self, path: syn::Path) -> TokenStream {
        let span = self.span();
        let ident = self.ident.to_owned();
        let macro_ident = generate_macro_ident(path);
        quote_spanned! {span=>
            #[macro_export]
            macro_rules! #macro_ident {
                ($i: ident :: $($rest: tt)?) => {
                    mod #ident {
                        $crate::$i($rest)!;
                    }
                };
                () => {
                    #self
                };
            }
        }
    }
}

impl PrustiExport for syn::ItemFn {
    fn export(&self, path: syn::Path) -> TokenStream {
        let span = self.span();
        let macro_ident = generate_macro_ident(path);
        quote_spanned! {span=>
            #[macro_export]
            macro_rules! #macro_ident {
                () => {
                    #self
                };
            }
        }
    }
}

impl PrustiExport for syn::ImplItemMethod {
    fn export(&self, path: syn::Path) -> TokenStream {
        let macro_ident = generate_macro_ident(path);
        quote_spanned!(self.span()=>
            #[macro_export]
            macro_rules! #macro_ident {
                () => {
                    #self
                };
            }
        )
    }
}

impl PrustiExport for syn::ItemImpl {
    fn export(&self, path: syn::Path) -> TokenStream {
        let ty_ref = self.self_ty.as_ref();
        let generic_bound = &self.generics;

        let macro_ident = generate_macro_ident(path);
        if let Some((_, trait_path, _)) = &self.trait_ {
            quote_spanned! {self.span()=>
                #[macro_export]
                macro_rules! #macro_ident {
                    ($i: ident :: $($rest: tt)?) => {
                        impl #generic_bound #trait_path for #ty_ref {
                            $i!($rest);
                        }
                    };
                    () => {
                        #self
                    };
                }
            }
        } else {
            quote_spanned! {self.span()=>
                #[macro_export]
                macro_rules! #macro_ident {
                    ($i: ident :: $($rest: tt)?) => {
                        impl #generic_bound #ty_ref {
                            $i!($rest);
                        }
                    };
                    () => {
                        #self
                    };
                }
            }
        }
    }
}
