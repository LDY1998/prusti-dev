use proc_macro2::{TokenStream, TokenTree};
use quote::{quote, quote_spanned, ToTokens};
use syn::spanned::Spanned;

/**
This file implemented a series of functions to generate a macro for exporting source code
The fn generate_macro_for_export is the entry point, where it generates the whole macro
The inner tokens of macros is composed by expanding all mod declarations at this level and
the export item itself
The macro name is generated by export item's identifier with hash of its module_path
Some concrete examples can be found on https://hackmd.io/xT60CoK6TG6a4DCQgUMC4w#Guide-level-explanation
*/

/// generate a hash of path
fn hash_path(path: syn::Path) -> u64 {
    use std::{
        collections::hash_map::DefaultHasher,
        hash::{Hash, Hasher},
    };
    let mut hasher = DefaultHasher::new();
    path.hash(&mut hasher);
    hasher.finish()
}

/// generate a macro identifier with given path in this format:
/// {last_segment in path}_{hash(path)}
pub fn generate_macro_ident(path: syn::Path) -> syn::Ident {
    let ident = path.segments.last().unwrap().ident.to_owned();
    syn::Ident::new(
        &format!("{}_{}_{}", "prusti_export", ident, hash_path(path)),
        ident.span(),
    )
}

/// generate macros for exporting rust source and specifications
/// the tokens of macro expanded to is the item as well as all its upper level mod declaration
/** 
    @path is where the item will be exported at, it is given by user
    @mod_path is the module path recorded when you encounter the item
    @item is the item to be exported
    @uses is all `use` statements at the same module level
    @type_path is the type item belongs to (for impl/method)

    based on the parameter, we will generate a macro similar to this:
        #[macro_export]
        macro_rules ident_hash(path) {
            () => {
                mod mod_path_seg_0 {
                    mod mod_path_seg_1 {
                        ...
                        uses
                        item
                        
                        Or if we have a type_path:
                        struct type_path{}
                        impl type_path {
                            item
                        }
                        
                    }
                }
            }
        };
*/
fn generate_macro_for_export<T: ToTokens>(
    path: &syn::Path,
    mod_path: &syn::Path,
    item: T,
    uses: &TokenStream,
    type_path: Option<syn::Path>,
) -> TokenStream {
    let macro_ident = generate_macro_ident(path.to_owned());
    let inner_tokens = if let Some(type_path) = type_path {
        expand_type_path_in_macro(&mod_path, quote!(#item), uses, type_path)
    } else {
        expand_mod_path_in_macro(&mod_path, quote!(#item), uses)
    };
    quote_spanned! {macro_ident.span() =>
        #[macro_export]
        #[prusti::export_spec_macro]
        macro_rules! #macro_ident {
            () => {
                #inner_tokens
            };
        }
    }
}

/// A helper trait to extract msg from item's attribute
/// Since syn::ImplMethodItem and the rest are not in the same enum
trait ItemWithAttr {
    fn get_attrs(&self) -> Vec<syn::Attribute>;
    fn get_path(&self, name: &str) -> Option<syn::Path> {
        if let Some(export_path_attr) = self.get_attrs().iter().find(|attr| {
            attr.path.segments.len() == 2
                && &attr.path.segments.last().unwrap().ident.to_string() == name
        }) {
            for tt in export_path_attr.tokens.to_owned() {
                if let TokenTree::Group(group) = tt {
                    return syn::parse2(group.stream()).ok();
                }
            }
            return None;
        }
        return None;
    }
}

fn get_path<T: ItemWithAttr>(name: &str, item: &T) -> Option<syn::Path> {
    item.get_path(name)
}

impl ItemWithAttr for syn::ItemFn {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

impl ItemWithAttr for syn::ItemMod {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

impl ItemWithAttr for syn::ItemImpl {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

impl ItemWithAttr for syn::ItemStruct {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

impl ItemWithAttr for syn::ImplItemMethod {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

/// expand the module path recorded when traversing AST
fn expand_mod_path_in_macro(
    path: &syn::Path,
    mut tokens: TokenStream,
    uses_same_level: &TokenStream,
) -> TokenStream {
    for seg in path.segments.to_owned().into_iter().rev() {
        tokens = quote!(
            mod #seg {
                #uses_same_level
                #tokens
            }
        );
    }
    tokens
}

/// Expand the type path recorded when an impl/method is rewritten
/// This is for rewriting an impl/method, since we will need to record
/// the path of its type
fn expand_type_path_in_macro(
    path: &syn::Path,
    tokens: TokenStream,
    uses_same_level: &TokenStream,
    type_path: syn::Path,
) -> TokenStream {
    let type_path_macro_ident = generate_macro_ident(type_path);
    expand_mod_path_in_macro(
        path,
        quote!(
            $crate::#type_path_macro_ident!();
            #tokens
        ),
        uses_same_level,
    )
}

pub fn rewrite_export_spec(path: &syn::Path, item: &syn::Item) -> syn::Result<TokenStream> {
    let mod_path = syn::Path {
        leading_colon: None,
        segments: syn::punctuated::Punctuated::new(),
    };

    match item {
        syn::Item::Fn(item_fn) => rewrite_fn(path, mod_path, item_fn, &TokenStream::new()),
        syn::Item::Mod(item_mod) => rewrite_mod(path, mod_path, item_mod, &TokenStream::new()),
        syn::Item::Impl(item_impl) => rewrite_impl(path, mod_path, item_impl, &TokenStream::new()),
        syn::Item::Struct(item_struct) => {
            rewrite_struct(item_struct, mod_path, &TokenStream::new())
        }
        _ => {
            // currently, export only support struct/mod/fn defs
            // TODO: Add support for other specs (enums/trait...)
            unimplemented!();
        }
    }
}

fn rewrite_mod(
    export_path: &syn::Path,
    mut mod_path: syn::Path,
    item_mod: &syn::ItemMod,
    uses_same_level: &TokenStream,
) -> syn::Result<TokenStream> {
    let mut path = export_path.to_owned();
    let mut macro_tokens = TokenStream::new();
    path.segments.push(syn::PathSegment {
        ident: item_mod.ident.clone(),
        arguments: syn::PathArguments::None,
    });

    if let Some(export_path) = get_path("export_path", item_mod) {
        path = export_path;
    }

    macro_tokens.extend(generate_macro_for_export(
        &path,
        &mod_path,
        quote!(#item_mod),
        uses_same_level,
        None,
    ));

    mod_path.segments.push(syn::PathSegment {
        ident: item_mod.ident.clone(),
        arguments: syn::PathArguments::None,
    });

    let mut uses = TokenStream::new();
    for item in item_mod.content.as_ref().unwrap().1.iter() {
        let mod_path = mod_path.to_owned();
        match item {
            syn::Item::Fn(item_fn) => {
                macro_tokens.extend(rewrite_fn(&path, mod_path, item_fn, &uses));
            }
            syn::Item::Impl(item_impl) => {
                macro_tokens.extend(rewrite_impl(&path, mod_path, item_impl, &uses)?);
            }
            syn::Item::Mod(item_mod) => {
                macro_tokens.extend(rewrite_mod(&path, mod_path, item_mod, &uses)?);
            }
            syn::Item::Struct(item_struct) => {
                macro_tokens.extend(rewrite_struct(item_struct, mod_path, &uses));
            }
            syn::Item::Use(item_use) => {
                uses.extend(quote!(#item_use));
            }
            _ => {
                return Err(syn::Error::new(
                    item.span(),
                    "expected a mod/fn/impl".to_string(),
                ));
            }
        }
    }

    Ok(macro_tokens)
}

fn rewrite_fn(
    export_path: &syn::Path,
    mod_path: syn::Path,
    item_fn: &syn::ItemFn,
    uses_same_level: &TokenStream,
) -> syn::Result<TokenStream> {
    let mut path = export_path.to_owned();
    let ident = item_fn.sig.ident.to_owned();
    path.segments.push(syn::PathSegment {
        ident: ident,
        arguments: syn::PathArguments::None,
    });
    if let Some(export_path) = get_path("export_path", item_fn) {
        path = export_path;
    }
    Ok(generate_macro_for_export(
        &path,
        &mod_path,
        quote!(#item_fn),
        uses_same_level,
        None,
    ))
}

fn rewrite_struct(
    item_struct: &syn::ItemStruct,
    mod_path: syn::Path,
    uses_same_level: &TokenStream,
) -> syn::Result<TokenStream> {
    let struct_ident = &item_struct.ident;
    let generics = &item_struct.generics;
    let struct_path: syn::Path = parse_quote_spanned!(item_struct.span() =>
        #struct_ident #generics
    );
    Ok(generate_macro_for_export(
        &struct_path,
        &mod_path,
        quote!(#item_struct),
        uses_same_level,
        None,
    ))
}

fn rewrite_impl(
    export_path: &syn::Path,
    mod_path: syn::Path,
    item_impl: &syn::ItemImpl,
    uses_same_level: &TokenStream,
) -> syn::Result<TokenStream> {
    let mut path = export_path.to_owned();
    if let syn::Type::Path(type_path) = item_impl.self_ty.as_ref() {
        path.segments.extend(type_path.path.segments.clone());
    }
    if let Some(export_path) = get_path("export_path", item_impl) {
        path = export_path;
    }

    if let Some(type_path) = get_path("type_path", item_impl) {
        parse_valid_export_type(&mut path);

        let mut tokens = TokenStream::new();
        tokens.extend(generate_macro_for_export(
            &path,
            &mod_path,
            quote!(#item_impl),
            uses_same_level,
            Some(type_path),
        ));

        for item in item_impl.items.iter() {
            match item {
                syn::ImplItem::Method(item_method) => {
                    tokens.extend(rewrite_method(&path, item_method, &mod_path)?);
                }
                _ => {
                    return Err(syn::Error::new(
                        item.span(),
                        "expected a method".to_string(),
                    ));
                }
            }
        }
        // tokens.extend(generate_macro_for_export(path, macro_content));
        Ok(tokens)
    } else {
        Err(syn::Error::new(
            item_impl.span(),
            "No valid type_path found for impl",
        ))
    }
}

fn rewrite_method(
    path: &syn::Path,
    item_method: &syn::ImplItemMethod,
    impl_mod_path: &syn::Path,
) -> syn::Result<TokenStream> {
    let mut path = path.to_owned();
    if let Some(type_path) = get_path("type_path", item_method) {
        path.segments.push(syn::PathSegment {
            ident: item_method.sig.ident.clone(),
            arguments: syn::PathArguments::None,
        });

        if let Some(export_path) = get_path("export_path", item_method) {
            path = export_path;
        }

        // get_prusti_path_in_attr!(item_method, "export_path", path);
        parse_valid_export_type(&mut path);
        Ok(generate_macro_for_export(
            &path,
            impl_mod_path,
            quote!(#item_method),
            &TokenStream::new(),
            Some(type_path),
        ))
    } else {
        Err(syn::Error::new(
            item_method.span(),
            "No valid type_path found for method",
        ))
    }
}

pub fn parse_valid_export_attr(attr: TokenStream) -> syn::Result<syn::Path> {
    let span = attr.span();
    if attr.is_empty() {
        Err(syn::Error::new(span, "export path must be non-empty"))
    } else {
        if attr.to_string().trim() == "::" {
            Ok(syn::Path {
                leading_colon: None,
                segments: syn::punctuated::Punctuated::new(),
            })
        } else {
            syn::parse2(attr).map_err(|_e| syn::Error::new(span, "invalid export path"))
        }
    }
}

fn parse_valid_export_type(ty_path: &mut syn::Path) {
    for seg in &mut ty_path.segments {
        if let syn::PathArguments::AngleBracketed(_) = &mut seg.arguments {
            seg.arguments = syn::PathArguments::None;
        }
    }
}
