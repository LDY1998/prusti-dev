use proc_macro2::{TokenStream, TokenTree};
use quote::{quote, quote_spanned, ToTokens};
use syn::{parse::Parse, spanned::Spanned};

/// An abstraction for tokens that user use to specify method trait bound
/// #[trait_bound(<T: Trait>)] | #[trait_bound(<T>)] | #[trait_bound(<T> where T: Trait1 + Trait2 ...)]
#[derive(Debug)]
pub struct PrustiTraitBound(syn::Generics);

impl Parse for PrustiTraitBound {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut generics: syn::Generics = input.parse()?;
        generics.where_clause = input.parse()?;
        Ok(Self(generics))
    }
}

/**
This file implemented a series of functions to generate a macro for exporting source code
The fn generate_macro_for_export is the entry point, where it generates the whole macro
The inner tokens of macros is composed by expanding all mod declarations at this level and
the export item itself
The macro name is generated by export item's identifier with hash of its module_path
Some concrete examples can be found on https://hackmd.io/xT60CoK6TG6a4DCQgUMC4w#Guide-level-explanation
*/

/// generate a hash of path
fn hash_path(path: syn::Path) -> u64 {
    use std::{
        collections::hash_map::DefaultHasher,
        hash::{Hash, Hasher},
    };
    let mut hasher = DefaultHasher::new();
    path.hash(&mut hasher);
    hasher.finish()
}

/// generate a macro identifier with given path in this format:
/// prustiexport_{last_segment in path}_{hash(path)}
/// First segment is for identifying a macro that is generated by prusti export
pub fn generate_macro_ident(path: syn::Path) -> syn::Ident {
    let ident = path.segments.last().unwrap().ident.to_owned();
    syn::Ident::new(
        &format!("{}_{}_{}", "prusti_export", ident, hash_path(path)),
        ident.span(),
    )
}

/// generate macros for exporting rust source and specifications
/// the tokens of macro expanded to is the item as well as all its upper level mod declaration
/**
    @path is where the item will be exported at, it is given by user
    @mod_path is the module path recorded when you encounter the item
    @item is the item to be exported
    @uses is all `use` statements at the same module level
    @type_path is the type item belongs to (for impl/method)

    based on the parameter, we will generate a macro similar to this:
        #[macro_export]
        macro_rules ident_hash(path) {
            () => {
                mod mod_path_seg_0 {
                    mod mod_path_seg_1 {
                        ...
                        uses
                        item

                        Or if we have a type_path:
                        struct type_path{}
                        impl type_path {
                            item
                        }

                    }
                }
            }
        };
*/
fn generate_macro_for_export<T: ToTokens>(
    path: &syn::Path,
    mod_path: &syn::Path,
    item: T,
    uses: &TokenStream,
    type_path: Option<syn::Path>,
) -> TokenStream {
    let macro_ident = generate_macro_ident(path.to_owned());
    let inner_tokens = if let Some(type_path) = type_path {
        let type_path_macro = generate_macro_ident(type_path);
        expand_mod_path_in_macro(mod_path, quote!($crate::#type_path_macro!(); #item), uses)
    } else {
        expand_mod_path_in_macro(mod_path, quote!(#item), uses)
    };
    quote_spanned! {macro_ident.span() =>
        #[macro_export]
        #[prusti::export_spec_macro]
        macro_rules! #macro_ident {
            () => {
                #inner_tokens
            };
        }
    }
}

/// A helper trait to extract msg from item's attribute
/// Since syn::ImplMethodItem and the rest are not in the same enum
trait ItemWithAttr {
    fn get_attrs(&self) -> Vec<syn::Attribute>;
    fn get_path(&self, name: &str) -> Option<syn::Path> {
        if let Some(export_path_attr) = self.get_attrs().iter().find(|attr| {
            attr.path.segments.len() == 2
                && attr.path.segments.last().unwrap().ident.to_string() == name
        }) {
            for tt in export_path_attr.tokens.to_owned() {
                if let TokenTree::Group(group) = tt {
                    return syn::parse2(group.stream()).ok();
                }
            }
            return None;
        }
        None
    }
}

fn get_path<T: ItemWithAttr>(name: &str, item: &T) -> Option<syn::Path> {
    item.get_path(name)
}

pub fn get_generics_for_method(item: &syn::ImplItemMethod) -> Option<PrustiTraitBound> {
    if let Some(generic) = item.attrs.iter().find(|attr| {
        attr.path.segments.len() == 1
            && &attr.path.segments.last().unwrap().ident.to_string() == "trait_bound"
    }) {
        for tt in generic.tokens.to_owned() {
            if let TokenTree::Group(group) = tt {
                return syn::parse2(group.stream()).ok();
            }
        }
        return None;
    }
    return None;
}

impl ItemWithAttr for syn::ItemFn {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

impl ItemWithAttr for syn::ItemMod {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

impl ItemWithAttr for syn::ItemImpl {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

impl ItemWithAttr for syn::ItemStruct {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

impl ItemWithAttr for syn::ImplItemMethod {
    fn get_attrs(&self) -> Vec<syn::Attribute> {
        self.attrs.to_owned()
    }
}

/// expand the module path recorded when traversing AST
fn expand_mod_path_in_macro(
    path: &syn::Path,
    mut tokens: TokenStream,
    uses_same_level: &TokenStream,
) -> TokenStream {
    for seg in path.segments.to_owned().into_iter().rev() {
        tokens = quote!(
            mod #seg {
                #uses_same_level
                #tokens
            }
        );
    }
    tokens
}

pub fn rewrite_export_spec(path: &syn::Path, item: &mut syn::Item) -> syn::Result<TokenStream> {
    let mod_path = syn::Path {
        leading_colon: None,
        segments: syn::punctuated::Punctuated::new(),
    };

    match item {
        syn::Item::Fn(item_fn) => rewrite_fn(path, mod_path, item_fn, &TokenStream::new()),
        syn::Item::Mod(item_mod) => rewrite_mod(path, mod_path, item_mod, &TokenStream::new()),
        syn::Item::Impl(item_impl) => rewrite_impl(path, mod_path, item_impl, &TokenStream::new()),
        syn::Item::Struct(item_struct) => {
            rewrite_struct(item_struct, mod_path, &TokenStream::new())
        }
        _ => {
            // currently, export only support struct/mod/fn defs
            // TODO: Add support for other specs (enums/trait...)
            unimplemented!();
        }
    }
}

fn rewrite_mod(
    export_path: &syn::Path,
    mut mod_path: syn::Path,
    item_mod: &mut syn::ItemMod,
    uses_same_level: &TokenStream,
) -> syn::Result<TokenStream> {
    let mut path = export_path.to_owned();
    let mut macro_tokens = TokenStream::new();
    path.segments.push(syn::PathSegment {
        ident: item_mod.ident.clone(),
        arguments: syn::PathArguments::None,
    });

    if let Some(export_path) = get_path("export_path", item_mod) {
        path = export_path;
    }

    macro_tokens.extend(generate_macro_for_export(
        &path,
        &mod_path,
        &*item_mod,
        uses_same_level,
        None,
    ));

    mod_path.segments.push(syn::PathSegment {
        ident: item_mod.ident.clone(),
        arguments: syn::PathArguments::None,
    });

    let mut uses = TokenStream::new();
    for item in item_mod.content.as_mut().unwrap().1.iter_mut() {
        let mod_path = mod_path.to_owned();
        match item {
            syn::Item::Fn(item_fn) => {
                macro_tokens.extend(rewrite_fn(&path, mod_path, item_fn, &uses));
            }
            syn::Item::Impl(item_impl) => {
                macro_tokens.extend(rewrite_impl(
                    &path,
                    mod_path,
                    &mut item_impl.to_owned(),
                    &uses,
                )?);
            }
            syn::Item::Mod(item_mod) => {
                macro_tokens.extend(rewrite_mod(&path, mod_path, item_mod, &uses)?);
            }
            syn::Item::Struct(item_struct) => {
                macro_tokens.extend(rewrite_struct(item_struct, mod_path, &uses));
            }
            syn::Item::Use(item_use) => {
                uses.extend(quote!(#item_use));
            }
            _ => {
                return Err(syn::Error::new(
                    item.span(),
                    "expected a mod/fn/impl".to_string(),
                ));
            }
        }
    }

    Ok(macro_tokens)
}

fn rewrite_fn(
    export_path: &syn::Path,
    mod_path: syn::Path,
    item_fn: &mut syn::ItemFn,
    uses_same_level: &TokenStream,
) -> syn::Result<TokenStream> {
    let mut path = export_path.to_owned();
    let ident = item_fn.sig.ident.to_owned();
    path.segments.push(syn::PathSegment {
        ident,
        arguments: syn::PathArguments::None,
    });
    if let Some(export_path) = get_path("export_path", &*item_fn) {
        path = export_path;
    }
    Ok(generate_macro_for_export(
        &path,
        &mod_path,
        &*item_fn,
        uses_same_level,
        None,
    ))
}

fn rewrite_struct(
    item_struct: &mut syn::ItemStruct,
    mod_path: syn::Path,
    uses_same_level: &TokenStream,
) -> syn::Result<TokenStream> {
    let struct_ident = &item_struct.ident;
    let generics = &item_struct.generics;
    let struct_path: syn::Path = parse_quote_spanned!(item_struct.span() =>
        #struct_ident #generics
    );
    Ok(generate_macro_for_export(
        &struct_path,
        &mod_path,
        &*item_struct,
        uses_same_level,
        None,
    ))
}

fn rewrite_impl(
    export_path: &syn::Path,
    mod_path: syn::Path,
    item_impl: &mut syn::ItemImpl,
    uses_same_level: &TokenStream,
) -> syn::Result<TokenStream> {
    let mut path = export_path.to_owned();
    if let syn::Type::Path(type_path) = item_impl.self_ty.as_ref() {
        path.segments.extend(type_path.path.segments.clone());
    }
    if let Some(export_path) = get_path("export_path", &*item_impl) {
        path = export_path;
    }

    if let Some(type_path) = get_path("type_path", item_impl) {
        parse_valid_export_type(&mut path);

        let mut tokens = TokenStream::new();
        for item in item_impl.items.iter() {
            match item {
                syn::ImplItem::Method(item_method) => {
                    tokens.extend(rewrite_method(&path, item_method, &mod_path, &*item_impl)?);
                }
                _ => continue,
            }
        }
        let methods_with_bound: TokenStream = item_impl
            .items
            .iter()
            .filter_map(|item| {
                if let syn::ImplItem::Method(item_method) = item {
                    if get_generics_for_method(item_method).is_some() {
                        Some(rewrite_method_to_impl(item_method, &*item_impl))
                    } else {
                        None
                    }
                } else {
                    None
                }
            })
            .map(|item| quote!(#item))
            .collect();

        item_impl.items = item_impl
            .items
            .to_owned()
            .into_iter()
            .filter(|item| {
                if let syn::ImplItem::Method(item_method) = item {
                    get_generics_for_method(item_method).is_none()
                } else {
                    true
                }
            })
            .collect::<Vec<syn::ImplItem>>();

        // the methods with trait bound is filtered out from the original impl item
        // they need to be added back to the tokens
        tokens.extend(methods_with_bound.clone());
        tokens.extend(generate_macro_for_export(
            &path,
            &mod_path,
            quote!(
                #item_impl
                #methods_with_bound
            ),
            uses_same_level,
            Some(type_path),
        ));

        Ok(tokens)
    } else {
        Err(syn::Error::new(
            item_impl.span(),
            "No valid type_path found for impl",
        ))
    }
}

/// rewrite a method to be a separate impl block
/// this is necessary when the user import the method only instead of the whole impl block
/// or if the method has a trait bound that is different from impl
/// the type info of impl needs to be preserved
pub fn rewrite_method_to_impl(
    item_method: &syn::ImplItemMethod,
    item_impl: &syn::ItemImpl,
) -> syn::ItemImpl {
    let mut new_impl_item = item_impl.clone();
    // preserve all impl items that are not method
    new_impl_item.items = new_impl_item
        .items
        .into_iter()
        .filter(|item| {
            !matches!(item, syn::ImplItem::Method(_))
        })
        .collect();
    new_impl_item
        .items
        .push(syn::ImplItem::Method(item_method.clone()));
    if let Some(generics) = get_generics_for_method(item_method) {
        new_impl_item.generics = generics.0;
    }
    new_impl_item
}
fn rewrite_method(
    path: &syn::Path,
    item_method: &syn::ImplItemMethod,
    impl_mod_path: &syn::Path,
    parent_item_impl: &syn::ItemImpl,
) -> syn::Result<TokenStream> {
    let mut path = path.to_owned();
    if let Some(type_path) = get_path("type_path", item_method) {
        path.segments.push(syn::PathSegment {
            ident: item_method.sig.ident.clone(),
            arguments: syn::PathArguments::None,
        });

        if let Some(export_path) = get_path("export_path", item_method) {
            path = export_path;
        }

        parse_valid_export_type(&mut path);
        Ok(generate_macro_for_export(
            &path,
            impl_mod_path,
            rewrite_method_to_impl(item_method, parent_item_impl),
            &TokenStream::new(),
            Some(type_path),
        ))
    } else {
        Err(syn::Error::new(
            item_method.span(),
            "No valid type_path found for method",
        ))
    }
}

pub fn parse_valid_export_attr(attr: TokenStream) -> syn::Result<syn::Path> {
    let span = attr.span();
    if attr.is_empty() {
        Err(syn::Error::new(span, "export path must be non-empty"))
    } else if attr.to_string().trim() == "::" {
        Ok(syn::Path {
            leading_colon: None,
            segments: syn::punctuated::Punctuated::new(),
        })
    } else {
        syn::parse2(attr).map_err(|_e| syn::Error::new(span, "invalid export path"))
    }
}

fn parse_valid_export_type(ty_path: &mut syn::Path) {
    for seg in &mut ty_path.segments {
        if let syn::PathArguments::AngleBracketed(_) = &mut seg.arguments {
            seg.arguments = syn::PathArguments::None;
        }
    }
}
